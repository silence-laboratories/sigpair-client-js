import * as ed from "@noble/ed25519";
import {
  P1Keygen,
  P1Keyshare,
  P1KeyshareV2,
  P1Signer,
  PartyKeys,
  SignWithRecId,
  generatePartyKeys,
} from "@silencelaboratories/two-party-ecdsa-js";
/**
 * Message type used for communication between the client and server
 */
export type Message = {
  signature: string;
  content: string;
};

/**
 * A signing request
 */
export type SignMessageRequest = {
  /**
   * Key ID of the keyshare to use
   */
  key_id: string;
  /**
   * BIP32 chain path to derive child key to sign. If not specified, defaults to "m". If you're not sure what this is, leave it as "m".
   */
  chain_path: string;
  /**
   * Hash of the message to sign as a hex string. Must be 32 bytes. Can be prefixed with 0x or not.
   */
  message_hash: string;
  /**
   * Base64 encoded message-1 from the client to the server
   */
  sign_msg1: string;
};

/**
 *  ed25519 Keypair used to sign messages, generated with `generateSigningKeys()`
 */
export type SignKeypair = {
  /**
   * Hex string, ed25519 sign private key
   */
  signingKey: string;
  /**
   * Hex string, ed25519 sign public key
   */
  publicKey: string;
};

/**
 * Convience function to generate ed25519 signing keys. The public key is passed to the Sigpair admin to generate a user token.
 * @returns ed25519 signing keys
 */
export async function generateSigningKeys(): Promise<SignKeypair> {
  const keys = ed.utils.randomPrivateKey();
  return {
    signingKey: ed.etc.bytesToHex(keys),
    publicKey: ed.etc.bytesToHex(await ed.getPublicKeyAsync(keys)),
  };
}

/**
 * Sigpair client to generate and refresh keyshares, and sign messages by communicating with the Sigpair server.
 */
export class SigpairClient {
  userToken: string;
  signingKey: Uint8Array;
  baseUrl: URL;
  /**
   * Create a new Sigpair client
   * @param userToken Hex string, User token generated by the Sigpair admin
   * @param signingKey Hex string, ed25519 signing keys to sign messages. Must have the same public key as in the generated user token.
   * @param baseUrl Base URL of the Sigpair server
   */
  constructor(userToken: string, signingKey: string, baseUrl: string) {
    this.userToken = userToken;
    this.signingKey = ed.etc.hexToBytes(signingKey);
    this.baseUrl = new URL(baseUrl);
  }

  /**
   * Update the user token used for future requests
   * @param token New user token to use for future requests
   */
  setNewToken(token: string) {
    this.userToken = token;
  }

  /**
   * Generate an ECDSA keyshare
   * @param partyKeys Keys required for MPC keygen, generated with `generatePartyKeys()`.
   * Can be reused for multiple keygen and refresh protocols.
   * @returns
   */
  async genECDSAKey(partyKeys: PartyKeys): Promise<P1KeyshareV2> {
    const socket = await this.connectSocket("/v2/ecdsa/keygen");
    socket.onclose = (event) => {};

    socket.onerror = (event) => {
      throw new Error("WebSocket error: " + event);
    };

    const keys = await generatePartyKeys();
    const p1 = await P1Keygen.init(keys);
    const msg1 = await p1.genMsg1();
    await sendMessage(msg1.msg_data, this.signingKey, socket);
    const message = await receiveMessage(socket, 10000);

    const [keyshare, msg3] = await p1.processMsg2({
      msg_data: message,
      msg_type: "KeyMsg2",
      instance_id: msg1.instance_id,
    });

    await sendMessage(msg3.msg_data, this.signingKey, socket);
    socket.close();
    return keyshare;
  }
  /**
   * Refresh an ECDSA keyshare
   * @param currKeyshare current keyshare to refresh
   * @param keys Party keys (keys used in keygen can be reused, or new keys can be generated with `generatePartyKeys()`
   * @returns Refreshed keyshare with the same public key.
   */
  async refreshECDSAKey(
    currKeyshare: P1KeyshareV2 | P1Keyshare,
    keys: PartyKeys
  ): Promise<P1KeyshareV2> {
    const socket = await this.connectSocket(
      `/v2/ecdsa/refresh?key_id=${currKeyshare.data.key_id}`
    );
    socket.onclose = (event) => {};

    socket.onerror = (event) => {
      throw new Error("WebSocket error: " + event);
    };

    const p1 = await currKeyshare.getRefreshInstance(keys);
    const msg1 = await p1.genMsg1();
    await sendMessage(msg1.msg_data, this.signingKey, socket);
    const message = await receiveMessage(socket, 10000);

    const [keyshare, msg3] = await p1.processMsg2({
      msg_data: message,
      msg_type: "KeyMsg2",
      instance_id: msg1.instance_id,
    });

    await sendMessage(msg3.msg_data, this.signingKey, socket);
    socket.close();
    return keyshare;
  }
  /**
   *
   * Generate an ECDSA signature
   * @param keyshare Keyshare to sign with
   * @param messageHash Hash of the message to sign as a hex string. Must be 32 bytes. Can be prefixed with 0x or not.
   * @param chainPath BIP32 chain path to derive child key to sign. If not specified, defaults to "m". If you're not sure what this is, leave it as "m".
   * @returns
   */
  async genECDSASign(
    keyshare: P1KeyshareV2,
    messageHash: string,
    chainPath: string = "m"
  ): Promise<SignWithRecId> {
    if (messageHash.startsWith("0x")) {
      messageHash = messageHash.slice(2);
    }
    const msgHashBytes = ed.etc.hexToBytes(messageHash);
    if (msgHashBytes.length != 32) {
      throw new Error("Message hash must be 32 bytes");
    }

    const socket = await this.connectSocket("/v2/ecdsa/sign");

    socket.onclose = async (event) => {};

    socket.onerror = (event) => {
      throw new Error("WebSocket error: " + event);
    };

    const p1 = await P1Signer.init(keyshare, msgHashBytes, chainPath);
    const msg1 = await p1.genMsg1();
    const msgReq: SignMessageRequest = {
      key_id: keyshare.data.key_id,
      chain_path: chainPath,
      message_hash: messageHash,
      sign_msg1: Buffer.from(msg1.msg_data).toString("base64"),
    };

    const msgReq2 = Buffer.from(JSON.stringify(msgReq));

    await waitForSocketOpen(socket);
    await sendMessage(msgReq2, this.signingKey, socket);

    const message = await receiveMessage(socket, 10000);

    const [signature, msg3] = await p1.processMsg2({
      msg_data: message,
      msg_type: "SignMsg2",
      instance_id: msg1.instance_id,
    });

    await sendMessage(msg3.msg_data, this.signingKey, socket);

    socket.close();
    return signature;
  }

  private async connectSocket(route: string): Promise<WebSocket> {
    const socket = new WebSocket(
      `ws://${this.baseUrl.hostname}:${this.baseUrl.port}${route}`,
      {
        //@ts-ignore
        headers: {
          Authorization: `Bearer ${this.userToken}`,
        },
      }
    );

    await waitForSocketOpen(socket);
    return socket;
  }
}

export class TimeoutError extends Error {
  constructor() {
    super("Timed out waiting for message");
    this.name = "TimeoutError";
  }
}

async function sendMessage(
  message: number[] | Uint8Array | Buffer,
  signingKey: Uint8Array,
  socket: WebSocket
) {
  const signature = await ed.signAsync(Uint8Array.from(message), signingKey);
  const msg: Message = {
    signature: Buffer.from(signature).toString("base64"),
    content: Buffer.from(message).toString("base64"),
  };
  socket.send(Buffer.from(JSON.stringify(msg)));
}

async function receiveMessage(
  socket: WebSocket,
  timeoutMs: number
): Promise<number[]> {
  let timeoutId: NodeJS.Timeout;
  return new Promise((resolve, reject) => {
    // Set up a timeout promise that resolves after the specified timeout
    const timeoutPromise = new Promise<number[]>((_, reject) => {
      timeoutId = setTimeout(() => {
        reject(new TimeoutError());
      }, timeoutMs);
    });

    // Race the actual message promise against the timeout promise
    Promise.race([
      timeoutPromise,
      new Promise((resolve) => {
        clearTimeout(timeoutId);
        socket.onmessage = (message) => {
          const msg: Message = JSON.parse(message.data.toString());
          resolve(Array.from(Buffer.from(msg.content, "base64")));
        };
      }),
    ])
      .then(resolve as (value: unknown) => void)
      .catch(reject);
  });
}

function waitForSocketOpen(socket: WebSocket): Promise<void> {
  return new Promise((resolve, reject) => {
    if (socket.readyState === WebSocket.OPEN) {
      resolve();
    } else {
      socket.onopen = () => resolve();
      socket.onerror = (event) => reject(event);
    }
  });
}
